---
layout: post
title:      "Ruby CLI Project #1: Quarantine Movie List Generator"
date:       2020-10-26 22:17:12 +0000
permalink:  ruby_cli_project_1_quarantine_movie_list_generator
---

An overview of the genesis for this project, and a recap of it's trials and tribulations.

It has been a quite start to my coding journey here at Flatiron, and it's hard to believe that we are already 6 weeks in!  Similar to how a movie has a plot, characters, a director, etc, a program contains classes, methods, and variables, each playing an integral role in carrying out the overall objective. Should even the seemingly most minor thing be out of place, it could result in the program breaking (or in other words, the story ending). I'm using this movie/program metaphor because I decided to develop a quarantine movie list generator for my first CLI project.

If you're alive and old enough to understand what's going on in the world in 2020, COVID-19 is something you will likely never forget. Due to the airborne and highly contagious nature of the virus, governments around the world have invoked stay at home orders to reduce the number of cases and keep people safe. As a result, more people have flocked to streaming services like Netflix and Hulu to occupy their time at home. The mission of this project is to provide movie recommendations for those wondering what to do with their extra time, and help them get their minds off the issues that are quite literally plaguing the world.

At first, this project seemed extremely daunting. Some of the most challenging labs over the last few weeks were the Object Oriented Programming labs (particularly "My Pets" and "Tic Tac Toe" come to mind). However, dedicating time every day to coding was a behavior that I tried to cement into a habit early on. Even carving out 30 minutes after work proved to be helpful.

The first step was copying over all of the Google docs provided so I can make them my own and build out my plan. I tried to not dwell too much on the API and ended up picking the Movie Database mainly because it seemed robust and not too complex to work with. Once I chose the API and outlined the user story, I felt much better about starting to write my code. Going into future projects, I plan on executing the same pre-planning process to ensure I have a good foundation to work off of. Additionally, I leaned on the support from my cohort lead (Madeline) and other students. Going to office hours almost daily forced me to commit time to the project, and also expose the concepts that I need to focus on.

Up until this point, I had a very basic understanding of what an API was. Through my various sales roles at technology companies, I've been on the periphery of API's. If you asked me to explain what it was, I wouldn't be able to, even at a high level. Now, having built a program that accesses data directly from an API, I'm so much more confident in my understanding of what it is and why it's important. The sharing of data can help other companies scale, while also giving others an opportunity to thrive. Gaining this knowledge is exactly why I wanted to enroll in Flatiron.

One of the major challenges I had with this project initially was scoping out the user flow, and what the messaging prompts should look like. Questions like *How do I want this app to function at a high-level?* *What should the user see? What messaging should get them to the next stage, and what should the next stage look like?* were starting to pile on. This, again, seemed overwhelming. However, very much like what I would imagine the movie script process might look like - once I built the overarching themes and started to map out the user journey, the code started to fall into place.

From a technical perspective, connecting to the right API was also a bit of a challenge. The API URL within the application today for example is not the initial URL I used. With the guidance of my cohort lead, I was able to determine a better fit for my project which ultimately included more robust data points (specifically, the movie title, vote average, overview, and release date). Additonally, recursion was a concept that had been recently introduced to our cohort, as it could be a good solution for ensuring that the program continues so long as the user wants to access more data. In my case, recursion is applied to solve for a situation in which a user wants to continue researching movies after the initial run through of the program. In the code, I've written a recursive call to re-display the movies. Recursion continues until the base case where the user rejects continuing to see the list. When that happens, the rejection will happen on the entire call set.

Once I started to build out the command line and see that methods I built in the CLI class were working, I added some more functionality to make the app more user-friendly. One of the ideas that was brought up during office hours was changing the text color. I did some research and found the Colorize gem. I installed it, tested it on, and lo and behold, it looked great! For the welcome messages, I selected Cyan as it really seemed to pop off the black terminal background. I incorporated green text for positive responses, and red for negative. For example, if the user wants to see a list of movies, the text appears in green. However, if they enter an invalid numerical selection, the system indicates that the input was invalid, in red. These may seem like trivial changes which don't really impact the functionality (they don't) but I'm proud of the additional research I did to make for a better user experience.

Ultimately, these past 2 weeks were challenging. It forced me to manage my time, outline what I wanted to do, test different things, fail, and fail, and fail again, until things really started to come together.  I've had to think critically and put my knowledge on key concepts to the test. By the end, I was able to prove to myself that it's something I can do and feel much more confident going into Sinatra week 1. I'm looking forward to the next 6 weeks and beyond!

